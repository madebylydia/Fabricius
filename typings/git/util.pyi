import logging
from abc import abstractmethod
from typing import (
    IO,
    Any,
    AnyStr,
    BinaryIO,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Tuple,
    TypeVar,
    Union,
)

from _typeshed import Incomplete
from git.config import GitConfigParser, SectionConstraint
from git.repo.base import Repo

from .types import Files_TD, PathLike, Protocol, SupportsIndex, Total_TD

T_IterableObj = TypeVar(
    "T_IterableObj", bound=Union["IterableObj", "Has_id_attribute"], covariant=True
)
HIDE_WINDOWS_KNOWN_ERRORS: Incomplete
T = TypeVar("T")

def unbare_repo(func: Callable[..., T]) -> Callable[..., T]: ...
def rmtree(path: PathLike) -> None: ...
def stream_copy(source: BinaryIO, destination: BinaryIO, chunk_size: int = ...) -> int: ...
def join_path(a: PathLike, *p: PathLike) -> PathLike: ...
def to_native_path_windows(path: PathLike) -> PathLike: ...
def to_native_path_linux(path: PathLike) -> str: ...

to_native_path = to_native_path_windows
to_native_path = to_native_path_linux

def join_path_native(a: PathLike, *p: PathLike) -> PathLike: ...
def assure_directory_exists(path: PathLike, is_file: bool = ...) -> bool: ...
def get_user_id() -> str: ...

class RemoteProgress:
    BEGIN: Incomplete
    END: Incomplete
    COUNTING: Incomplete
    COMPRESSING: Incomplete
    WRITING: Incomplete
    RECEIVING: Incomplete
    RESOLVING: Incomplete
    FINDING_SOURCES: Incomplete
    CHECKING_OUT: Incomplete
    STAGE_MASK: Incomplete
    OP_MASK: Incomplete
    DONE_TOKEN: str
    TOKEN_SEPARATOR: str
    re_op_absolute: Incomplete
    re_op_relative: Incomplete
    error_lines: Incomplete
    other_lines: Incomplete
    def __init__(self) -> None: ...
    def new_message_handler(self) -> Callable[[str], None]: ...
    def line_dropped(self, line: str) -> None: ...
    def update(
        self,
        op_code: int,
        cur_count: Union[str, float],
        max_count: Union[str, float, None] = ...,
        message: str = ...,
    ) -> None: ...

class CallableRemoteProgress(RemoteProgress):
    def __init__(self, fn: Callable) -> None: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...

class Actor:
    name_only_regex: Incomplete
    name_email_regex: Incomplete
    env_author_name: str
    env_author_email: str
    env_committer_name: str
    env_committer_email: str
    conf_name: str
    conf_email: str
    name: Incomplete
    email: Incomplete
    def __init__(self, name: Optional[str], email: Optional[str]) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    @classmethod
    def committer(
        cls, config_reader: Union[None, "GitConfigParser", "SectionConstraint"] = ...
    ) -> Actor: ...
    @classmethod
    def author(
        cls, config_reader: Union[None, "GitConfigParser", "SectionConstraint"] = ...
    ) -> Actor: ...

class Stats:
    total: Incomplete
    files: Incomplete
    def __init__(self, total: Total_TD, files: Dict[PathLike, Files_TD]) -> None: ...

class IndexFileSHA1Writer:
    f: Incomplete
    sha1: Incomplete
    def __init__(self, f: IO) -> None: ...
    def write(self, data: AnyStr) -> int: ...
    def write_sha(self) -> bytes: ...
    def close(self) -> bytes: ...
    def tell(self) -> int: ...

class LockFile:
    def __init__(self, file_path: PathLike) -> None: ...
    def __del__(self) -> None: ...

class BlockingLockFile(LockFile):
    def __init__(
        self, file_path: PathLike, check_interval_s: float = ..., max_block_time_s: int = ...
    ) -> None: ...

class IterableList(List[T_IterableObj]):
    def __new__(cls, id_attr: str, prefix: str = ...) -> IterableList[IterableObj]: ...
    def __init__(self, id_attr: str, prefix: str = ...) -> None: ...
    def __contains__(self, attr: object) -> bool: ...
    def __getattr__(self, attr: str) -> T_IterableObj: ...
    def __getitem__(self, index: Union[SupportsIndex, int, slice, str]) -> T_IterableObj: ...
    def __delitem__(self, index: Union[SupportsIndex, int, slice, str]) -> None: ...

class IterableClassWatcher(type):
    def __init__(cls, name: str, bases: Tuple, clsdict: Dict) -> None: ...

class Iterable(metaclass=IterableClassWatcher):
    @classmethod
    def list_items(cls, repo: Repo, *args: Any, **kwargs: Any) -> Any: ...
    @classmethod
    def iter_items(cls, repo: Repo, *args: Any, **kwargs: Any) -> Any: ...

class IterableObj(Protocol):
    @classmethod
    def list_items(cls, repo: Repo, *args: Any, **kwargs: Any) -> IterableList[T_IterableObj]: ...
    @classmethod
    @abstractmethod
    def iter_items(cls, repo: Repo, *args: Any, **kwargs: Any) -> Iterator[T_IterableObj]: ...

class NullHandler(logging.Handler):
    def emit(self, record: object) -> None: ...
