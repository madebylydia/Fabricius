from typing import Any, Iterator, TypeVar, Union

from _typeshed import Incomplete
from git.objects.commit import Commit
from git.refs import Head, Reference, RemoteReference, TagReference
from git.repo import Repo
from git.types import Commit_ish, PathLike

from .log import RefLog, RefLogEntry

T_References = TypeVar("T_References", bound="SymbolicReference")

class SymbolicReference:
    repo: Incomplete
    path: Incomplete
    def __init__(self, repo: Repo, path: PathLike, check_path: bool = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def abspath(self) -> PathLike: ...
    @classmethod
    def dereference_recursive(cls, repo: Repo, ref_path: Union[PathLike, None]) -> str: ...
    def set_commit(
        self, commit: Union[Commit, "SymbolicReference", str], logmsg: Union[str, None] = ...
    ) -> SymbolicReference: ...
    def set_object(
        self, object: Union[Commit_ish, "SymbolicReference", str], logmsg: Union[str, None] = ...
    ) -> SymbolicReference: ...
    commit: Incomplete
    object: Incomplete
    def set_reference(
        self, ref: Union[Commit_ish, "SymbolicReference", str], logmsg: Union[str, None] = ...
    ) -> SymbolicReference: ...
    reference: Union["Head", "TagReference", "RemoteReference", "Reference"]
    ref = reference
    def is_valid(self) -> bool: ...
    @property
    def is_detached(self) -> bool: ...
    def log(self) -> RefLog: ...
    def log_append(
        self, oldbinsha: bytes, message: Union[str, None], newbinsha: Union[bytes, None] = ...
    ) -> RefLogEntry: ...
    def log_entry(self, index: int) -> RefLogEntry: ...
    @classmethod
    def to_full_path(cls, path: Union[PathLike, "SymbolicReference"]) -> PathLike: ...
    @classmethod
    def delete(cls, repo: Repo, path: PathLike) -> None: ...
    @classmethod
    def create(
        cls,
        repo: Repo,
        path: PathLike,
        reference: Union["SymbolicReference", str] = ...,
        logmsg: Union[str, None] = ...,
        force: bool = ...,
        **kwargs: Any
    ) -> T_References: ...
    def rename(self, new_path: PathLike, force: bool = ...) -> SymbolicReference: ...
    @classmethod
    def iter_items(
        cls, repo: Repo, common_path: Union[PathLike, None] = ..., *args: Any, **kwargs: Any
    ) -> Iterator[T_References]: ...
    @classmethod
    def from_path(cls, repo: Repo, path: PathLike) -> T_References: ...
    def is_remote(self) -> bool: ...
